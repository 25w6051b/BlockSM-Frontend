// 日々行ったことをここに記載する
// 行った処理とその理由や注意点をまとめて記載(見返したときにどういう意図で行っているのか，どこまで行っているかを明確にする)

1124
・effectブロックの実装
　- effectはinput_valueで返すためタプル型を用いた
・if, else ifブロックの実装(切り替えブロック)
・実行ボタンの実装

1125
・motionruleを2つbehaviorを2つ設定するとエラーが出る
・文字列で返す時に""が付くので条件式が反応しないことがあった
→　条件式にも""を付ければ解決
・return はなにも返さないよう調整
→ 文字列をそのまま返すとeval()できないから？　全部""で統一したがいいかわからない　
  コンソールで出力したときに出力順番に差が出てしまうのでどちらかに統一すべきではありそう
・初期の開発で用いたファイル(イベントリスナーや音ブロックなどを作成したファイル)はonedriveの研究フォルダに移動
・初期の開発で用いたファイルは削除した

1127
・ブロック単体での実行時にエラーが出るのを改善した
→ retrunで文字列単体を返す場合は，親ブロックの有無を調べる　
　調べた結果，親ブロックがあれば文字列単体を返し，なければコンソールでその内容を出力する
・ボタンの配置を変更
・「動き」を「状態」に名前変更した
・火のついている，ついていないによって出力を変更した
→ 自動化が出来るかわからないのでやらなくていいかも
→ errorkeyを用いることで実装した　
　できるだけ汎用ブロックのコードを変更したくなかったため制限を設けたいブロック内でエラーキーを用いることで制御することとした　
　エラーキーは使いまわすため，使用時は管理をしっかりと行う　※で検索できるようにしておくように
・ボタンの配置，押されたときのリアクションをわかりやすいようにした

1204
・ボタン，ヘッダーに意図しない入力バーが表示されるバグの発見
→ 新しいボタンを定義しなおしても表示されるのでjavascriptの問題ではないことが分かった
→ mdl-buttonに設定されているものは表示されない
→ ヘッダーにも表示されるからもともとのhtmlが原因？
・開始疑似状態の設定ができるようなブロックを作成
→ 初期状態として設定させることで開始疑似状態の概念を理解させる
・「はじめに」，「ずっと」，「という作用が起こる」．「という状態に変わる」ブロックの改善
→ ブロックが挿入されていない時，エラーメッセージを出力

1205
・「ブロックが接続・挿入されていなければコンソールにエラーメッセージを出力する」という役割を持つ関数を実装
→ 関数名はcheckForChildBlock
→ ブロックが挿入されていなければ，エラーメッセージを出力し，挿入されていればなにも返さない
→ ブロックがつながっていなければ問題なのでブロックの関数の最初に配置する
・change_state_nobondブロックをchange_state_withbondに変更
→ 言葉のつながりがおかしくてもブロックをつなげられるようにした
・終了状態を実装し，遷移後は状態を変えることができないようにした
→ 状態をリセットする機能が必須
・「motionrules」ブロックで「behavior」ブロックで参照し，出力するときに空白が開いてしまうバグを改善
→ trim()を用いて空白を削除した
・退場動作の実装
→ 次の状態に遷移するタイミングで「おわりに～」と出力させるようにした
→ exitkeyとexitstatementを用いて実装
→ exitkeyは「おわりに」ブロックが認識されたことを確認する変数
→ exitstatementは「おわりに」ブロックが認識された際に，コンソールに出力すべき内容を保存しておく変数
→ 2つの変数の使い方としては，「という状態に変わる」ブロックが実行されるタイミングで
　exitkeyがtrueのとき(「おわりに」ブロックを認識しているとき)にexitstatementを出力する
・「～という作用が起こる」ブロックは「～という状態に変わる」ブロック以降にしか設置できないように改善
→ statemntに「effect_motionrules」を設定
・「～という状態に変わる」ブロックは「swich」カテゴリのブロックとつなぎ合わせられるように改善
・初期状態にトリガーを持たせられないように改善
→ 「もし～というイベントが起きたなら」ブロック内で現在の状態を調べ，「初期状態」ならif文を通さないようにした
・電源が切れた時は換気扇が切れるようにした

1208
・コンソールの出力内容を表示する領域を作成
→ 関数で通常の内容を出力
→ 関数logErrorでエラーメッセージを出力
→ innerTextでは領域内の文字列が上書きされる？ので使わない方が得策かも
→ appendChildを用いると良さそう
・点火後に点火が出来てしまっていたので改善
→ processStateWithParentCheck関数内でmotionerrorkeyで管理しているが，汎用性のない関数となったため改善必須
→ あくまで一時しのぎのため，behaviorクラス以外でブロック単体での実行を行う場合は改善必須
・すべてのエラーメッセージを赤色で出力
→ ブロックの組み合わせエラーと要求文に依存するエラーを対象とした

1209
・「初めの状態は～とする」ブロックを削除
→ そもそも初期状態しか入らないのでもともと設定しておいてもいいと判断した
→ 退場動作や終了状態を使用するときにエラーが発生しやすいのも原因
・現在の状態を表示する領域を作成
→ 今どの状態にいるかがわかりやすくなっているため初学者には理解しやすいと考えられる

1210
・一般化を行うために「イベント名」をボタン名にした
→ それの伴ってevent,eventkeyを設けてイベントの発生を制御した

1211
・trigger,behavior,effectのブロックを一般化した
→ variable_settingにそれぞれの名前を定義することでブロックを自動で作成できるようにした
→ ただし，要求文に依存する処理は行えないのでどうするかは検討
・イベントボタンの関数を簡略化した
→ イベントリスナーで呼び出す関数を一つの関数に省略した
→ アロー関数を用いて実装した
・要求文に依存するブロックは～namesリストに保存されている分だけ定義するようにした(mainファイル)

1212
・ボタンにカーソルを合わせた時にボタンの背景が暗くなるように設定
→ cssでhoverを用いることで実装

1215
・ボタンの自動作成
→ button_settingファイルで作成
・サブ状態の検討
→ 実行フローの一貫性を取ることが最優先だが，直感的ではないかもしれないので要検討
・ボタンの設定の検討
→ 実行ボタン以外でもワークスペース内のブロックを実行できてしまうのは問題である(直感的ではない)と感じたため改良
→ イベントボタンはあくまでイベントの設定に限り，実行は実行ボタンで行うことで直感的になると考えた
→ あくまで検討なので誰かにやってもらうのがいいかも

1216
・「初めの状態は～とする」ブロックの実行時，ブロックの透明度をあげた
→ 初めの状態は一回しか設定できないので，透明度を上げることで実行後はもう実行されないことを明確にできる
→ リセットをすることで色は元に戻せるような挙動とした
→ ブロック全体の透明度を上げるというやり方もあるが，これをするとつなげたブロックも透明になってしまうため色を薄くするという処置をしている
→ テキストに関しては，上記の現象が起こらないためアクセスして透明度を上げている

1218
・状態が行う動作と遷移を個別に管理
→ 遷移した後に実行する動作を毎回書く手間が減る
→ 関数を用いて動作を定義

1220
・カテゴリボックス内のブロックの色を変更した
→ Blockly.defineBlocksWithJsonArrayを再定義することで実現可能
→ カラープロパティにはアクセスできない？(ワークスペース上のブロックの色は干渉できる)っぽいのでこの方法しかないと思われる
→ 再定義すると警告が表示されるが，実行環境に問題はないので無視できるようにした(関数を用いた)
→ 関数reset_~(color)にcolorを代入することで色を変えてブロックの再定義が出来る

1228
・ブロックの文字列をすべて漢字に変更した
→ 大学生向けに絞るため

1231
・ガードの実装
→ ガードが存在するときのみブロックが出現する
→ エフェクトとガードそれぞれに対応したブロックが出現する
→ ガードは(==,<,>,<=,>=)を実装
→ エフェクトは(=,+=,-=)を実装
・イベントのelse ifブロックの実装
→ イベントが複数持てるようにブロックをいくつも繋げられるようにした

0103
・イベント，ガード，エフェクトがない時に必要のないブロックは削除するようにした
→ 例．ガードがなくても親のガードブロック(ガードがtrueの時に処理を行うブロック)を触れてしまうのは問題に感じたため
→ ただ，colornumberで定義した色でブロックの定義を行うため，ブロックの定義自体は全てのブロックについて行うこととした
→ ブロックの定義後，カテゴリボックスに追加するタイミングでイベントなどがあるかを確認し，無ければカテゴリボックスに追加しないという処置とした
・繋げられないブロックの色を変更する処理を改良した
→ guardブロックに繋げられるブロックを指定し，選択されるたびに色を変更した

0307
・astahファイルとの連携を行った
→ javaファイルを作成し，astahファイルの読み込みおよび要求文に依存する要素の取得を行った
→ javaのバージョンが21,23のいずれでも出来なかったため1.8とした(7?か9?以上のバージョンだと対応できないライブラリがあったため，そのライブラリがないとエラー解消ができないため1.8にした)
→ ライブラリはプログラムファイルにあるastahのファイルからjarファイルを全てもってきたため，不必要なものもある可能性大

0314
・javaとjs間で値の受け渡しを行った(astahのデータを渡すため)
→ Spring bootでサーバーを立てた(javaで取得したastahのデータをサーバーに預ける)
→ サーバーのjdkが21しかなかったため，21にしたがastahで動くかは不明
→ サーバーからfetchでjsに値の取得を行った
→ 非同期処理になってるため，値の取得順序が入れ替わってしまうため，関数で囲って.thenでブロックの処理を全部囲わないといけないかもしれない

0317
・既存の変数名をキャメルケースに変更した

0321
・spring bootのバージョンを2.54に変更した(javaのバージョンが8でしかastahの情報が取れないので変更した)
→ 変更方法はpomファイル内で変更
→ javaのバージョンも同じく変更した
・astahのデータ取得とサーバーの起動を同じjavaファイルで行う

0326
・変数カテゴリを追加した
→ 条件と作用に含まれる変数をこのカテゴリで表示されるようにした
→ 変数は条件と作用のどちらにも使われるため，新しく設けた

0401 
・jsからサーバーへのワークスペースの情報を送れるようにした
→ jsでpostし，サーバーで受け取る形とした
→ ワークスペースの情報以外は送れていない

0403
・サーバーとデータベース間での通信環境を整えた
→ データベースにはmySQLを用いた
→ stmBpDbデータベースにおいて，テーブルusersに(id,name,password,data)のカラムを作成した
→ webサイトからjsへ"名前"と"パスワード"を取得できる入力フィールドを作成した
→ "データを保存"ボタンと結び付け，入力内容を取得できるようにした
→ パスワードは入力時，確認できないようにしている(type = password)
→ jsからサーバーへ送信後，データベースへ送れる処理を今後行う

0417
・サーバーとwebサイトをドッカーでまとめて配れるかを試した
→ サーバーとwebサイトはastahのデータを共有するために利用しているが，ローカルのため配布はできない
→ 公開サーバーで行うとコストと通信環境を整えるのが厳しいためドッカーで各自インストールしてもらうこととした
→ サーバーの構築に使用しているspringbootのアプリケーションがあると，dockerではライブラリの手動設定が出来なかった
→ そのため，pomファイルにastahなどのライブラリを追加した
→ astah-api.jarとastah-pro.jarはmavenの中央リポジトリに存在しないため，mavenのローカルリポジトリに保存した
→ Springbootの場合プロジェクト自体？をjarファイルとしてdockerで読み込めるため，ローカルリポジトリでも問題ないと判断した

0418
dockerにまとめる方法について記載する(プロジェクト内にも同様の内容を記載したファイルを保存)

  バックエンド
  ・powershellを開く
  ・作成したjavaファイルのpom.xml下に移動する
  ・「mvn clean package」と打ち込み，プロジェクトのfatjarを作成
  ・このjarファイルはプロジェクト内のtargetフォルダに保存されているためコピーする
  ・コピーしたjarファイルをbackendフォルダのdockerfileと同じディレクトリに置く
  ・dockerfie内のjarの情報を書き換える(COPY部分を変更)

  フロントエンド
  ・プロジェクト自体をfrontendフォルダに入れる(htmlだけじゃなくcssなども同じディレクトリ下に置く)
  ・dockerfileのコピーはhtmlだけでよい(実装済み)

  その他，迷わないため
  ・fatjarはプロジェクト(アプリケーション)のプログラムに加え，依存関係も含めてjarファイルとできる
  ・fatjarを用いれば，mavenのローカルリポジトリに情報がなくても問題なく，dockerで起動できる
  ・研究で用いたastah-apiなどのライブラリは，mavenで依存関係を決めるとなると手動で追加，もしくはmaven
  　のローカルリポジトリにダウンロードしてpomを使って呼び出すという形式であった．(astahファイルはmavenの中央リポジトリには存在しないため)
  ・もし，dockerを用いて手動でastah-apiなどのライブラリを設定するには，dockerfile内のCMD命令に"cp"を用いてライブラリを指定する必要がある．
  　しかし，本研究においては，サーバーとしてSpringBootを用いているため"cp"コマンドが使えないという弊害があった．
  　(Springbootでは必要なライブラリをすべて含むfatjarを作成するため，後に依存関係を追加することが困難である)

  0425
  ・astahのデータ取得をwebサイトの構築と分割した
  → 以前まではサーバーでastahのデータを取得→webサイトで学習用環境を構築としていたが，astahの権利などの問題からこの形式を変えることとした
  → javaのプログラムでastahのデータをjsonに変換→jsonをサーバーからwebサイトに送って構築？という流れとする
  → 要求文に依存する要素をastahからすでに抜き出せていたのでplantumlなどは使わずにjsonとする
  → よってdockerも構築も見直す必要あり

  0509
  ・保存＆復元機能の確認
  → ワークスペースの保存はブロックの情報をxmlデータに変換してブラウザのストレージに保存することとした
  → ワークスペースの復元はxmlデータをdom？に変換後，bloklyの関数(clearWorkspaceAndLoadFromXml)を用いて行う

  0514
  ・保存＆復元機能の実装
  → データの保存は「直前のデータを復元」と「前回の"動作テスト"時のデータを復元」の二つの保存方法を考えた
  → 「直前のデータを復元」は一定時間ごとにデータを取得し保存する(setIntervalを用いた)
  → また，直前のデータを更新する際についてだが，ワークスペース上にデータがない場合は，更新しなくても良いのではないか？と検討している
  → 「前回の"動作テスト"時のデータを復元」は動作テストボタンが押下時に保存されるものとしている
  → 各保存方法に対応する復元方法として「データの復元」というプルダウンメニューを作成した
  → 各データの保存は時系列でとるのではなく，あくまで一つのデータ領域を更新するものとなっているため，更新すると元に戻せない(毎回新しいデータとしてキーを与えて保存すると，ブラウザのストレージに収まらないため)
  
  0520
  ・ガードの改善
  → ガードが開始疑似状態から遷移するときも使用できるようになっていたため，使えないようにした
  → 厳密には実行結果としてエラーを表示するものとした

  0529
  ・保存機能の削除
  → 保存機能の「前回の"動作テスト"時のデータを復元」は削除した(復元できるタイミングを選べないのは使えないため)
  ・ユーザー自身がデータを保存・復元する機能の実装
  → ユーザーが「データの保存」ボタンを選択すると入力欄(input)が出現し，そこに文字列を入力することで保存できることとした
  → 追加ボタンを押すとローカルストレージと「データの復元」ボタンのメニューに項目が追加される
  → 改善点としてローカルストレージは一意のキーしか持てないため注意を促すことが必要
  → データの削除機能もないと常にローカルストレージにデータが残り続ける可能性あり
  → キーは空文字でも送れてしまうのでこれも防ぐ方がよい

  0608
  ・モデル図への変換過程の調整
  → モデルへの変換過程として，下記にまとめた
    １．ブロックプログラムで作成したステートマシンをplantUmlに変換する
    ２．plantUmlをファイル形式でサーバー側に送信する
    ３．サーバー側で受け取ったファイルを用いてステートマシン図の画像を出力する
    ４．画像をwebサイトへ送信する
    ５．webサイト上で画像を表示する
  ・plantUmlからステートマシン図の作成可能かの確認
  → plantUmlファイルをプロジェクト上に入れると，モデル図に変換したpngファイルが出力されることが確認できた

  0609
  ・ブロックプログラムからplantUmlへの変換
  → 「図に変換」というボタンを作成した
  → このボタンはブロックプログラムで作成したステートマシンをブロックプログラムに変換できるようにするものである
  → plantUmlに変換時，状態ごとにイベントやガードなどの付属情報を取得しなければならない
  → そのため，状態を入れるブロック「今の状態が～のとき」．「状態が～のときの動きは」ブロックを取得して，その中に含まれる状態名を抜き出せるようにした
  → そこから，再帰的に必要な情報を取得する必要がある
  → 状態が変わった場合，別の状態としてjsonにイベントなどを保存できるようにする必要があり

  0611
  ・ブロックプログラムからplantUmlに変換
  → 前回に引き続き，状態ごとにイベントなどの情報をjson形式で保存できるようにした
  → 次回はplantUml形式に変換しサーバー側に送る処理を行う

  0727
  ・初期状態がない場合はそもそもステートマシン図を表示しないこととした
  → plantUmlは初期状態と初期状態からの遷移がないとそもそも画像化されないため，前回までは初期状態はあるものとして画像化していた
  → しかし，配置されていない初期状態を出力するのは混乱を招きそうなので，エラー文を出力することとした
  → エラー文はあまり出したくなかったが，plantUmlの仕様上しょうがないものとする

  0728
  ・「動き」ブロックを実行するときに，画像を出力することとした
  → 画像はchatgptで生成したが，課題ごとに作成しなければならない
  → 画像の名前は動きブロックと連携させ，すべての動きブロックにおいて画像は必要である
  → 画像の出力順序はステートマシンと一致しており前回の状態のexit,entry,doの順番に実行するものとする(3秒間隔で)
  → 動きブロックを持っていない状態においてもずっと前回の状態の画像が表示されるので，使用者によっては違和感に気づけないかも
  → 画像を消すことも考えたが，トリガーが難しくそのままとしている

  1003
  ・カテゴリボックス内にブロックが存在しないカテゴリは表示しないものとした
  → ブロックが存在しないのにカテゴリを開いてしまうという無駄な動作を減らすため
  → カテゴリボックスを定義する際に，json内のリストを確認後，なければカテゴリを追加しないものとした